#!/usr/bin/python
#Castro Rendon Virgilio
import socket
from struct import *

first = lambda byte : byte >> 4
second = lambda byte : byte & 0xF

def tab(line):
	line = int(len(line)/2)
	if line in (7,8): return ""
	if line in (5,6): return "\t\t"
	if line in (3,4): return "\t\t\t"
	else: return "\t\t\t\t\t"

#tcpdump-like print
def printL(l):
	hexa,i = "\t",0
	for byte in l:
		hexa += "%s%s" % (str(hex(first(byte)))[2:],str(hex(second(byte)))[2:])
		i += 1
		if i%2 == 0: hexa+=" "
	hexa += tab(l)
	hexa += "   "
	for byte in l:
		hexa+=chr(byte) if (byte < 127 and byte > 39) else "."
	print hexa


def printH(header, linea):
	for i in range(len(header)):
		if len(linea) == 16 or i == len(header)-1:
			printL(linea)
			linea = [header[i]]
		else: linea += [header[i]]
	return linea


prot = {1:"ICMP",6:"TCP",17:"UDP"}
s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
while True:
	linea = []
	packet = s.recvfrom(65565)[0]
	iph = unpack('!BBHHHBBH4s4s',packet[0:20]) #If fully used, this would serve to get each ip-header field
	iphlength = second(iph[0])*4 #last 4 bits of the first field * 4 (says length in 32bit-words)
	iphbytes = unpack('!%sB' % iphlength, packet[0:iphlength])
	tcph = unpack('!HHLLBBHHH', packet[iphlength:iphlength+20]) #Wieder, aber mit TCP
	tcphlength = first(tcph[4])*4
	noDataL = iphlength + tcphlength
	tcphbytes = unpack('!%sB' % tcphlength, packet[iphlength:noDataL]) #unpacks n the bytes of tcp, from the end of the ip header to the last byte of the tcp header
	souip, desip = socket.inet_ntoa(iph[8]), socket.inet_ntoa(iph[9])
	print "\n\n\t%s:%s  ->  %s:%s" % (souip,tcph[0],desip,tcph[1]) #Source and destinations addresses and ports
	print "\tProtocol:%s\tTTL:%s" % (prot[iph[6]],iph[5])
	print "\t-----------------------------------------------------------"
	linea = printH(iphbytes, linea)
	linea = printH(tcphbytes, linea)
	p2 = map(ord,packet[noDataL:])
	linea = printH(p2, linea)
